<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Financeiro Completo Unificado</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.2.0/css/all.min.css">
    <style>
        /* --- Estilos (Moderno/Minimalista) --- */
        :root {
            --clr-primary: #4a90e2; /* Primary Blue */
            --clr-secondary: #50e3c2; /* Aqua */
            --clr-text: #333;
            --clr-text-light: #777;
            --clr-bg: #f9fafb; /* Very light gray */
            --clr-white: #ffffff;
            --clr-border: #e5e7eb; /* Lighter border */
            --clr-receipt: #3498db;    /* Blue */
            --clr-payment: #e74c3c;    /* Red */
            --clr-delivery: #9b59b6;   /* Purple */
            --clr-success: #2ecc71;    /* Green */
            --clr-warning: #f39c12;    /* Yellow */
            --clr-danger: #f87171;     /* Lighter Red for overdue icon */
            --clr-dark: #34495e;       /* Dark color */
            --clr-muted: #7f8c8d;
            --radius: 6px;
            --shadow-sm: 0 1px 2px 0 rgba(0, 0, 0, 0.05);
            --shadow-md: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
        }
        *, *::before, *::after { box-sizing: border-box; margin: 0; padding: 0; }
        body {
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol";
            background-color: var(--clr-bg); color: var(--clr-text); font-size: 14px; line-height: 1.6;
        }
        .app-container { max-width: 1500px; margin: 1.5rem auto; background-color: var(--clr-white); border-radius: var(--radius); box-shadow: var(--shadow-md); overflow: hidden; }

        /* Header & Filters */
        .app-header { padding: 1rem 1.5rem; background-color: var(--clr-white); border-bottom: 1px solid var(--clr-border); display: flex; flex-direction: column; gap: 0.8rem; }
        .header-top { display: flex; justify-content: space-between; align-items: center; width: 100%; }
        .header-top h1 { font-size: 1.5rem; margin: 0; color: var(--clr-dark); display: flex; align-items: center; gap: 0.5rem; font-weight: 600; }
        .header-top .action-buttons { display: flex; gap: 0.5rem; }
        .action-buttons button { padding: 6px 12px; border-radius: 5px; border: none; cursor: pointer; font-weight: 500; font-size: 0.9rem; transition: background-color 0.2s ease; display: inline-flex; align-items: center; gap: 5px;}
        #btn-add-entry { background-color: var(--clr-success); color: white; }
        #btn-reports { background-color: var(--clr-dark); color: white; }


        .filter-bar { display: flex; justify-content: space-between; align-items: center; flex-wrap: wrap; gap: 1rem; width: 100%; }
        .filter-group { display: flex; align-items: center; gap: 0.5rem; background-color: var(--clr-bg); padding: 4px; border-radius: var(--radius); }
        .filter-group button { padding: 6px 12px; border: none; border-radius: 5px; background-color: transparent; color: var(--clr-text-light); cursor: pointer; font-size: 0.85rem; font-weight: 500; transition: background-color 0.2s ease, color 0.2s ease; }
        .filter-group button:hover:not(.active) { background-color: #e8e8e8; }
        .filter-group button.active { color: var(--clr-white); box-shadow: var(--shadow-sm); }
        .filter-group button.active[data-filter-type="all"],
        .filter-group button.active[data-filter-status="all"] { background-color: var(--clr-primary); }
        .filter-group button.active[data-filter-type="receipt"] { background-color: var(--clr-receipt); }
        .filter-group button.active[data-filter-type="payment"] { background-color: var(--clr-payment); }
        .filter-group button.active[data-filter-type="delivery"] { background-color: var(--clr-delivery); }
        .filter-group button.active[data-filter-status="pending"] { background-color: var(--clr-warning); color: var(--clr-dark);} /* Texto escuro aqui também */
        .filter-group button.active[data-filter-status="paid"] { background-color: var(--clr-success); }
        .filter-group button.active[data-filter-status="overdue"] { background-color: var(--clr-danger); }

        /* Summary Bar */
        .summary-bar { display: grid; grid-template-columns: repeat(auto-fit, minmax(130px, 1fr)); gap: 1px; background-color: var(--clr-border); border-bottom: 1px solid var(--clr-border); }
        .summary-item { background-color: var(--clr-white); text-align: center; padding: 12px 5px; transition: opacity 0.3s ease, max-height 0.3s ease, padding 0.3s ease; }
        .summary-item .value { font-size: 1.2rem; font-weight: 600; display: block; }
        .summary-item .label { font-size: 0.7rem; color: var(--clr-text-light); text-transform: uppercase; }
        .summary-item .value.receipt { color: var(--clr-success); }
        .summary-item .value.payment { color: var(--clr-danger); }
        .summary-item .value.pending { color: var(--clr-warning); }
        .summary-item .value.danger { color: var(--clr-danger); }
        .summary-item .value.delivery-count { color: var(--clr-delivery);}
        .summary-item.hidden { padding-top: 0; padding-bottom: 0; max-height: 0; opacity: 0; overflow: hidden; border: none; margin: 0; }


        /* Calendar */
        .calendar-container { padding: 1rem 1.5rem; }
        .calendar-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 1rem; }
        .calendar-header .month-display { font-size: 1.4rem; font-weight: 600; }
        .calendar-header button { background: none; border: none; font-size: 1.4rem; cursor: pointer; color: var(--clr-primary); padding: 5px;}
        .calendar-grid { display: grid; grid-template-columns: repeat(7, 1fr); gap: 8px; }
        .day-label { text-align: center; font-weight: 500; color: var(--clr-text-light); padding-bottom: 0.5rem; font-size: 0.75rem; text-transform: uppercase; }
        .day-cell { min-height: 115px; border: 1px solid var(--clr-border); border-radius: var(--radius); background-color: var(--clr-white); padding: 8px; font-size: 0.8rem; cursor: pointer; transition: background-color 0.2s, box-shadow 0.2s; display: flex; flex-direction: column; position: relative; }
        .day-cell.other-month { background-color: var(--clr-bg); cursor: default; pointer-events: none; opacity: 0.6; }
        .day-cell.today { border-width: 2px; border-color: var(--clr-primary); }
        .day-cell:hover:not(.other-month) { box-shadow: var(--shadow-sm); background-color: #fdfdff; }
        .day-number { text-align: right; font-weight: 500; margin-bottom: 6px; color: var(--clr-text-light); font-size: 0.8rem;}
        .day-cell.today .day-number { color: var(--clr-primary); font-weight: bold; }
        .day-entries { flex-grow: 1; overflow: hidden; }
        .entry-icon-list { display: flex; flex-wrap: wrap; gap: 6px; padding-top: 4px; }
        .entry-icon { font-size: 1.1rem; padding: 4px; border-radius: 4px; width: 24px; height: 24px; display: inline-flex; justify-content: center; align-items: center; position: relative; color: var(--clr-white); opacity: 1; transition: opacity 0.2s ease; }
        .entry-icon.receipt { background-color: var(--clr-receipt); }
        .entry-icon.payment { background-color: var(--clr-payment); }
        .entry-icon.delivery { background-color: var(--clr-delivery); }
        .entry-icon.completed { opacity: 0.4; }
        .entry-icon.overdue { border: 2px solid var(--clr-danger); color: var(--clr-danger); background-color: transparent; padding: 2px; }
        .entry-icon.completed.overdue { border-color: var(--clr-success); }
        .more-entries-indicator { font-size: 0.75rem; color: var(--clr-text-light); margin-top: 6px; text-align: center; }

        /* Modal Styles */
        .modal { display: none; position: fixed; z-index: 1000; left: 0; top: 0; width: 100%; height: 100%; overflow: auto; background-color: rgba(0,0,0,0.4); animation: fadeIn 0.2s ease-out; }
        .modal-content { background-color: var(--clr-white); margin: 5% auto; padding: 25px; border-radius: var(--radius); width: 90%; max-width: 550px; box-shadow: var(--shadow-md); animation: slideIn 0.2s ease-out; }
        .modal-header { display: flex; justify-content: space-between; align-items: center; border-bottom: 1px solid var(--clr-border); padding-bottom: 10px; margin-bottom: 20px; }
        .modal-header h2 { margin: 0; font-size: 1.25rem; font-weight: 600; color: var(--clr-dark); }
        .modal-close-btn { background: none; border: none; font-size: 1.6rem; color: var(--clr-muted); cursor: pointer; padding: 0 5px; line-height: 1; }
        .modal-body { max-height: 60vh; overflow-y: auto; padding-right: 5px;}
        .modal-footer { margin-top: 25px; padding-top: 15px; border-top: 1px solid var(--clr-border); text-align: right; }
        .modal-footer button { padding: 8px 18px; border-radius: 5px; border: none; cursor: pointer; margin-left: 10px; font-weight: 500;}
        .modal-footer .btn-cancel { background-color: var(--clr-muted); color: white; }
        .modal-footer .btn-save { background-color: var(--clr-success); color: white; }
          /* Report Modal Specifics */
          .report-modal .modal-content { max-width: 700px; }
          .report-section { margin-bottom: 20px; padding-bottom: 15px; border-bottom: 1px solid #eee; }
          .report-section:last-child { border-bottom: none; }
          .report-section h3 { font-size: 1.1rem; color: var(--clr-dark); margin-bottom: 10px; }
          #report-balancete p, #report-demonstrativo-list div p { margin: 4px 0; font-size: 0.95rem;}
          #report-demonstrativo-list div { padding: 10px; margin-bottom: 8px; background-color: #f9f9f9; border-radius: 4px; }
          #report-demonstrativo-list strong { font-weight: 600; }
          #balancete-saldo.positivo { color: var(--clr-success); }
          #balancete-saldo.negativo { color: var(--clr-danger); }

        /* Day Details Modal Specifics */
        #day-detail-entries .day-entry { border: 1px solid var(--clr-border); padding: 12px; margin-bottom: 10px; border-radius: 5px; background-color: #fdfdfd;}
        #day-detail-entries h4 { margin: 0 0 8px 0; font-size: 1rem; display: flex; align-items: center; gap: 8px;}
        #day-detail-entries h4 i { min-width: 15px; text-align: center; font-size: 0.9rem; color: var(--clr-muted);}
        #day-detail-entries h4 i.fa-dollar-sign { color: var(--clr-receipt);}
        #day-detail-entries h4 i.fa-receipt { color: var(--clr-payment);}
        #day-detail-entries h4 i.fa-truck { color: var(--clr-delivery);}
        #day-detail-entries p { margin: 3px 0; font-size: 0.9rem; color: var(--clr-text-light); }
        #day-detail-entries p strong { color: var(--clr-text); font-weight: 500;}
        .day-entry-actions { margin-top: 10px; padding-top: 10px; border-top: 1px dashed var(--clr-border); display: flex; gap: 8px; flex-wrap: wrap; }
        .day-entry-actions button, .day-entry-actions a { padding: 6px 12px; font-size: 0.8rem; border-radius: 4px; border: none; cursor: pointer; display: inline-flex; align-items: center; gap: 5px; text-decoration: none; font-weight: 500;}
        .day-entry-actions button:disabled { opacity: 0.5; cursor: not-allowed; }
        .day-entry-actions .btn-paid, .day-entry-actions .btn-delivered { background-color: var(--clr-success); color: white; }
        /* --- BOTÃO EDITAR ATUALIZADO --- */
        .day-entry-actions .btn-edit {
            background-color: var(--clr-warning); /* Amarelo */
            color: var(--clr-dark); /* Texto escuro para contraste */
        }
        /* --- FIM DA ATUALIZAÇÃO --- */
        .day-entry-actions .btn-delete { background-color: var(--clr-danger); color: white; }
        .day-entry-actions .btn-whatsapp { background-color: #25D366; color: white; }
        .day-entry-actions .btn-view-order { background-color: var(--clr-muted); color: white; }

          /* Add/Edit Form */
          .form-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 15px 20px; }
          .form-group { display: flex; flex-direction: column; }
          .form-group label { margin-bottom: 5px; font-weight: 500; color: var(--clr-muted); font-size: 0.85rem; }
          .form-group input, .form-group select { width: 100%; padding: 9px 10px; border: 1px solid var(--clr-border); border-radius: 5px; font-size: 0.9rem; height: 38px; background-color: var(--clr-white); }
          .form-group input[type="checkbox"] { width: auto; height: auto; margin-right: 5px; position: relative; top: 2px;}
          .form-group.checkbox-group { flex-direction: row; align-items: center; }
          .form-group.checkbox-group label { margin-bottom: 0; }
          .form-group.full-width { grid-column: span 2; }

        /* Responsive Adjustments */
        @media (max-width: 992px) { .filter-bar { flex-direction: column; align-items: stretch; gap: 0.8rem;} .filter-group { justify-content: center; } }
        @media (max-width: 768px) { body { padding: 10px; } .app-header { padding: 0.8rem 1rem; } .header-top { flex-direction: column; align-items: flex-start; gap: 0.5rem;} .header-top .action-buttons { width: 100%; justify-content: flex-end;} .summary-bar { grid-template-columns: repeat(auto-fit, minmax(100px, 1fr)); } .calendar-container { padding: 0.8rem; } .calendar-grid { gap: 4px; } .day-cell { min-height: 95px; font-size: 0.75rem;} .entry-icon { width: 20px; height: 20px; font-size: 0.9rem;} .modal-content { margin: 5% auto; padding: 20px; max-width: 95%; } }
        @media (max-width: 480px) { body { padding: 5px; font-size: 13px; } .app-header h1 { font-size: 1.2rem; } .filter-bar { gap: 0.5rem; } .filter-group { flex-wrap: wrap;} .filter-group button { padding: 5px 8px; font-size: 0.8rem;} .summary-bar { grid-template-columns: 1fr 1fr; } .summary-item .value { font-size: 1rem;} .calendar-container { padding: 0.5rem; } .day-cell { min-height: 85px; } .entry-icon { width: 18px; height: 18px; font-size: 0.8rem;} .form-grid { grid-template-columns: 1fr; } .form-group.full-width { grid-column: span 1; } }

          /* Animations & Utilities */
          @keyframes fadeIn { from { opacity: 0; } to { opacity: 1; } }
          @keyframes slideIn { from { transform: translateY(-15px); opacity: 0; } to { transform: translateY(0); opacity: 1; } }
          .loading-indicator { text-align: center; padding: 20px; color: var(--clr-muted); }
          .hidden { display: none !important; }
    </style>
</head>
<body>
    <div class="app-container">
        <header class="app-header">
            <div class="header-top">
                <h1><i class="fas fa-calendar"></i> Calendario</h1>
                <div class="action-buttons">
                    <button id="btn-add-entry"><i class="fas fa-plus"></i> Novo Lançamento</button>
                    <button id="btn-reports"><i class="fas fa-chart-pie"></i> Relatórios</button>
                </div>
            </div>
            <div class="filter-bar">
                <div class="filter-group" id="filter-group-type">
                    <button data-filter-type="all" class="active">Tudo</button>
                    <button data-filter-type="receipt">Recebimentos</button>
                    <button data-filter-type="payment">Pagamentos</button>
                    <button data-filter-type="delivery">Entregas</button>
                </div>
                <div class="filter-group" id="filter-group-status">
                    <button data-filter-status="all" class="active">Todos Status</button>
                    <button data-filter-status="pending">Pendentes</button>
                    <button data-filter-status="paid">Concluídos</button>
                    <button data-filter-status="overdue">Atrasados</button>
                </div>
            </div>
        </header>

        <main class="app-main">
            <div class="summary-bar">
                <div class="summary-item" id="summary-item-recebido">
                    <span class="value receipt" id="summary-recebido">R$ 0,00</span>
                    <span class="label">Recebido Mês</span>
                </div>
                <div class="summary-item" id="summary-item-a-receber">
                    <span class="value pending" id="summary-a-receber">R$ 0,00</span>
                    <span class="label">A Receber Mês</span>
                </div>
                <div class="summary-item" id="summary-item-pago">
                    <span class="value payment" id="summary-pago">R$ 0,00</span>
                    <span class="label">Pago Mês</span>
                </div>
                <div class="summary-item" id="summary-item-a-pagar">
                    <span class="value pending" id="summary-a-pagar">R$ 0,00</span>
                    <span class="label">A Pagar Mês</span>
                </div>
                <div class="summary-item hidden" id="summary-item-deliveries">
                    <span class="value delivery-count" id="summary-deliveries-count">0</span>
                    <span class="label">Entregas Mês</span>
                </div>
                <div class="summary-item" id="summary-item-vencido">
                    <span class="value danger" id="summary-vencido">R$ 0,00</span>
                    <span class="label">Vencido Total</span>
                </div>
            </div>

            <div class="calendar-container">
                <div class="calendar-header">
                    <button id="prev-month" title="Mês Anterior"><i class="fas fa-chevron-left"></i></button>
                    <span class="month-display" id="month-display">Carregando...</span>
                    <button id="next-month" title="Próximo Mês"><i class="fas fa-chevron-right"></i></button>
                </div>
                <div class="calendar-grid" id="calendar-labels">
                    <div class="day-label">Dom</div> <div class="day-label">Seg</div> <div class="day-label">Ter</div>
                    <div class="day-label">Qua</div> <div class="day-label">Qui</div> <div class="day-label">Sex</div> <div class="day-label">Sáb</div>
                </div>
                <div class="calendar-grid" id="calendar-days">
                    <div class="loading-indicator" style="grid-column: span 7;"><i class="fas fa-spinner fa-spin"></i> Carregando calendário...</div>
                </div>
            </div>
        </main>
    </div>

    <div id="day-detail-modal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <h2 id="day-detail-title">Detalhes do Dia</h2>
                <button class="modal-close-btn" data-modal-id="day-detail-modal">&times;</button>
            </div>
            <div class="modal-body" id="day-detail-entries"></div>
            <div class="modal-footer">
                <button type="button" class="btn-cancel" data-modal-id="day-detail-modal">Fechar</button>
            </div>
        </div>
    </div>

    <div id="entry-modal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <h2 id="entry-modal-title">Novo Lançamento</h2>
                <button class="modal-close-btn" data-modal-id="entry-modal">&times;</button>
            </div>
            <form id="entry-form">
                <input type="hidden" id="entry-id">
                <input type="hidden" id="entry-original-id">
                <input type="hidden" id="entry-is-generated">
                <div class="form-grid">
                    <div class="form-group full-width">
                        <label for="entry-type">Tipo</label>
                        <select id="entry-type" required> <option value="receipt" selected>Recebimento</option> <option value="payment">Pagamento</option> </select>
                    </div>
                    <div class="form-group full-width"> <label for="entry-description">Descrição</label> <input type="text" id="entry-description" required> </div>
                    <div class="form-group"> <label for="entry-value">Valor (R$)</label> <input type="number" id="entry-value" step="0.01" required> </div>
                    <div class="form-group"> <label for="entry-date">Data Venc./Pgto.</label> <input type="date" id="entry-date" required> </div>
                    <div class="form-group receipt-field full-width"> <label for="entry-client">Cliente</label> <select id="entry-client"><option value="">Nenhum</option></select> </div>
                    <div class="form-group payment-field hidden"> <label for="entry-supplier">Fornecedor</label> <input type="text" id="entry-supplier"> </div>
                    <div class="form-group payment-field hidden"> <label for="entry-recurrence">Recorrência</label> <select id="entry-recurrence"> <option value="none" selected>Não Repete</option> <option value="weekly">Semanal</option> <option value="monthly">Mensal</option> </select> </div>
                    <div class="form-group payment-field hidden checkbox-group full-width"> <input type="checkbox" id="entry-paid"> <label for="entry-paid">Marcar Pago?</label> </div>
                </div>
            </form>
            <div class="modal-footer">
                <button type="button" class="btn-cancel" data-modal-id="entry-modal">Cancelar</button>
                <button type="submit" class="btn-save" form="entry-form">Salvar</button>
            </div>
        </div>
    </div>

    <div id="report-modal" class="modal report-modal">
        <div class="modal-content">
            <div class="modal-header">
                <h2 id="report-title">Relatórios do Mês</h2>
                <button class="modal-close-btn" data-modal-id="report-modal">&times;</button>
            </div>
            <div class="modal-body">
                <div class="report-section">
                    <h3><i class="fas fa-file-invoice-dollar"></i> Balancete</h3>
                    <div id="report-balancete">
                        <p>Recebimentos Pagos: <span id="balancete-recebido">R$ 0,00</span></p>
                        <p>Pagamentos Efetuados: <span id="balancete-pago">R$ 0,00</span></p>
                        <p><strong>Saldo: <span id="balancete-saldo">R$ 0,00</span></strong></p>
                    </div>
                </div>
                <div class="report-section">
                    <h3><i class="fas fa-users"></i> Demonstrativo de Recebimentos por Cliente</h3>
                    <div id="report-demonstrativo-list">
                        <p class="placeholder">Nenhum recebimento no mês.</p>
                    </div>
                </div>
            </div>
            <div class="modal-footer">
                <button type="button" class="btn-cancel" data-modal-id="report-modal">Fechar</button>
            </div>
        </div>
    </div>


    <script type="module">
        // Firebase Imports
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.0/firebase-app.js";
        import { getFirestore, collection, addDoc, getDocs, doc, updateDoc, query, orderBy, deleteDoc, where, Timestamp, writeBatch, getDoc } from "https://www.gstatic.com/firebasejs/11.6.0/firebase-firestore.js";

        // Firebase Config - ** SUBSTITUA COM OS SEUS DADOS DO FIREBASE **
        // Configuração Firebase
        const firebaseConfig = {
            apiKey: "AIzaSyCVkb1-tdd5SL8jA2Cw2B0aeugu8SaCUBc", authDomain: "testebosspro.firebaseapp.com", projectId: "testebosspro",
            storageBucket: "testebosspro.appspot.com", messagingSenderId: "73684788134", appId: "1:73684788134:web:7c8250c83f10a2df59e567",
            measurementId: "G-1H29L5B830"
        };
        const app = initializeApp(firebaseConfig);
        const db = getFirestore(app);

        // --- Global State & DOM Elements Cache ---
        let currentDate = new Date();
        let allDbEntries = []; let displayedEntries = []; let clients = [];
        let currentFilters = { type: 'all', status: 'all' }; let isLoading = false;
        // Cache de Elementos DOM
        const calendarDaysEl=document.getElementById('calendar-days'), monthDisplayEl=document.getElementById('month-display'), prevMonthBtnEl=document.getElementById('prev-month'), nextMonthBtnEl=document.getElementById('next-month'), filterTypeGroup=document.getElementById('filter-group-type'), filterStatusGroup=document.getElementById('filter-group-status'), btnAddEntry=document.getElementById('btn-add-entry'), summaryItemRecebido=document.getElementById('summary-item-recebido'), summaryItemAReceber=document.getElementById('summary-item-a-receber'), summaryItemPago=document.getElementById('summary-item-pago'), summaryItemAPagar=document.getElementById('summary-item-a-pagar'), summaryItemDeliveries=document.getElementById('summary-item-deliveries'), summaryItemVencido=document.getElementById('summary-item-vencido'), summaryRecebidoEl=document.getElementById('summary-recebido'), summaryAReceberEl=document.getElementById('summary-a-receber'), summaryPagoEl=document.getElementById('summary-pago'), summaryAPagarEl=document.getElementById('summary-a-pagar'), summaryVencidoEl=document.getElementById('summary-vencido'), summaryDeliveriesCountEl=document.getElementById('summary-deliveries-count'), dayDetailModalEl=document.getElementById('day-detail-modal'), dayDetailTitleEl=document.getElementById('day-detail-title'), dayDetailEntriesEl=document.getElementById('day-detail-entries'), entryModalEl=document.getElementById('entry-modal'), entryModalTitleEl=document.getElementById('entry-modal-title'), entryFormEl=document.getElementById('entry-form'), entryIdInput=document.getElementById('entry-id'), entryOriginalIdInput=document.getElementById('entry-original-id'), entryIsGeneratedInput=document.getElementById('entry-is-generated'), entryTypeSelect=document.getElementById('entry-type'), entryClientSelect=document.getElementById('entry-client'), entryRecurrenceSelect=document.getElementById('entry-recurrence'), entryPaidCheckbox=document.getElementById('entry-paid'), receiptFields=entryModalEl.querySelectorAll('.receipt-field'), paymentFields=entryModalEl.querySelectorAll('.payment-field'), modalCloseBtns=document.querySelectorAll('[data-modal-id]'), btnReports=document.getElementById('btn-reports'), reportModalEl=document.getElementById('report-modal'), reportBalanceteRecebidoEl=document.getElementById('balancete-recebido'), reportBalancetePagoEl=document.getElementById('balancete-pago'), reportBalanceteSaldoEl=document.getElementById('balancete-saldo'), reportDemonstrativoListEl=document.getElementById('report-demonstrativo-list');

        // --- Utility Functions ---
        const formatCurrency = (v) => isNaN(v)?'R$ 0,00':`R$ ${Number(v).toFixed(2).replace('.',',')}`;
        const formatDate = (d) => {if(!d||!/^\d{4}-\d{2}-\d{2}$/.test(d))return 'N/A';const[y,m,day]=d.split('-');return`${day}/${m}/${y}`;};
        const parseDate = (d) => {if(!d||!/^\d{4}-\d{2}-\d{2}$/.test(d))return null;const[y,m,day]=d.split('-');return new Date(Date.UTC(Number(y),Number(m)-1,Number(day)));};
        const toISODateString = (d) => {if(!d||!(d instanceof Date))return'';return d.toISOString().split('T')[0];};
        const getMonthName = (m) => ['Janeiro','Fevereiro','Março','Abril','Maio','Junho','Julho','Agosto','Setembro','Outubro','Novembro','Dezembro'][m]; // Nomes completos
        const createEmptyDayElement = () => {const d=document.createElement('div');d.className='day-cell other-month';return d;};
        const adjustDateForFirestore = (d) => {if(!d)return null;if(/^\d{4}-\d{2}-\d{2}$/.test(d))return d;try{const dt=new Date(d+'T00:00:00');if(!isNaN(dt.getTime()))return toISODateString(dt);}catch(e){}return null;};

        // --- Data Loading & Processing ---
        function setLoadingState(loading) {
            isLoading = loading;
            btnAddEntry.innerHTML = isLoading ? '<i class="fas fa-spinner fa-spin"></i> Carregando...' : '<i class="fas fa-plus"></i> Novo Lançamento';
            btnAddEntry.disabled = isLoading;
            // Adicionar feedback visual para outras ações se necessário
        }
        async function loadClients() {
            try {
                const q = query(collection(db, "clientes"), orderBy("empresa")); // Ou orderBy("nome") se preferir
                const snap = await getDocs(q);
                clients = snap.docs.map(doc=>({ id: doc.id, ...doc.data() }));
                // Limpa e preenche o select de clientes
                entryClientSelect.innerHTML = '<option value="">Nenhum</option>';
                clients.forEach(c => {
                    const o=document.createElement('option');
                    // Guarda ID, Nome e Telefone no value como JSON string
                    o.value = JSON.stringify({ id: c.id, nome: c.empresa || c.nome, telefone: c.telefone });
                    o.textContent = `${c.empresa || c.nome || 'Cliente Sem Nome'} (${c.codigo || 'S/C'})`; // Mostra nome/empresa e código
                    entryClientSelect.appendChild(o);
                });
                console.log(`Clientes carregados: ${clients.length}`);
            } catch (e) {
                console.error("Erro ao carregar clientes:", e);
                // Tratar erro (ex: mostrar mensagem ao usuário)
            }
        }
        async function loadAllData() {
            if(isLoading) return;
            setLoadingState(true);
            console.log("Iniciando carregamento de todos os dados...");
            try {
                const cp = loadClients(); // Carrega clientes em paralelo
                // Prepara queries para recebimentos, pagamentos e pedidos
                const rq = query(collection(db, "recebimentos"), orderBy("dataPagamento"));
                const pq = query(collection(db, "pagamentos"), orderBy("dataPagamento"));
                const dq = query(collection(db, "pedidos"), where("dataEntregaOficial", "!=", null)); // Apenas pedidos com data de entrega

                // Executa todas as queries em paralelo
                const [receiptsSnap, paymentsSnap, deliveriesSnap] = await Promise.all([
                    getDocs(rq),
                    getDocs(pq),
                    getDocs(dq),
                    cp // Espera o carregamento de clientes também
                ]);

                allDbEntries = []; // Limpa array antes de preencher

                // Processa Recebimentos
                receiptsSnap.forEach(doc => {
                    const data = doc.data();
                    if(data.dataPagamento) { // Garante que há data
                        allDbEntries.push({
                            id: doc.id,
                            type: 'receipt',
                            description: data.descricao || 'Recebimento N/A',
                            value: Number(data.valor) || 0,
                            date: data.dataPagamento, // Assume formato YYYY-MM-DD
                            clientId: data.clienteId || null,
                            clientName: data.clienteNome || null, // Pode ser preenchido depois se necessário
                            clientPhone: data.telefone || null,   // Armazena telefone
                            isPaid: data.pago || false,
                            isGenerated: false, // Recibos não são gerados por recorrência neste modelo
                            isRecurringRule: false,
                            recurrenceType: 'none',
                            originalId: null,
                            createdAt: data.createdAt?.toDate() || null // Converte Timestamp para Date
                        });
                    }
                });

                // Processa Pagamentos
                paymentsSnap.forEach(doc => {
                    const data = doc.data();
                    if(data.dataPagamento) {
                        allDbEntries.push({
                            id: doc.id,
                            type: 'payment',
                            description: data.descricao || 'Pagamento N/A',
                            value: Number(data.valor) || 0,
                            date: data.dataPagamento,
                            supplier: data.fornecedor || null,
                            supplierContact: data.contatoFornecedor || null, // Se houver
                            isPaid: data.pago || false,
                            isRecurringRule: data.isRecurringRule || false,
                            recurrenceType: data.recurrenceType || data.recorrencia || 'none', // Compatibilidade
                            originalId: data.originalRuleId || null,
                            isGenerated: data.isGenerated || false,
                            createdAt: data.createdAt?.toDate() || null
                        });
                    }
                });

                // Processa Entregas (Pedidos)
                deliveriesSnap.forEach(doc => {
                    const data = doc.data();
                    if(data.dataEntregaOficial && typeof data.dataEntregaOficial === 'string') {
                        // Tenta encontrar o nome do cliente no array já carregado
                        const clientInfo = clients.find(c => c.id === data.clienteId);
                        const clientName = data.clienteNome || clientInfo?.empresa || clientInfo?.nome || 'Cliente N/A';

                        allDbEntries.push({
                            id: doc.id, // ID do pedido
                            type: 'delivery',
                            description: `Entrega Pedido #${data.numeroPedido || doc.id.substring(0, 6).toUpperCase()}`, // Descrição padrão
                            date: data.dataEntregaOficial, // Data da entrega
                            clientName: clientName,
                            clientId: data.clienteId || null,
                            isDelivered: data.entregue || false, // Status da entrega
                            numeroPedido: data.numeroPedido || null,
                            orcamentoId: data.orcamentoId || null, // ID do orçamento para link
                            value: 0, // Entregas não têm valor financeiro direto aqui
                            isPaid: data.entregue || false, // Considera 'pago' como 'entregue' para filtros
                            isGenerated: false,
                            isRecurringRule: false,
                            recurrenceType: 'none',
                            originalId: null,
                            createdAt: data.createdAt?.toDate() || null
                        });
                    }
                });

                // Ordena todas as entradas pela data (importante para a exibição)
                allDbEntries.sort((a, b) => (a.date || '').localeCompare(b.date || ''));

                console.log(`Dados carregados e processados. Total de entradas: ${allDbEntries.length}`);
                applyFiltersAndUpdateUI(); // Atualiza a interface com os dados carregados

            } catch (error) {
                console.error("Erro fatal ao carregar dados:", error);
                alert("Falha ao carregar os dados financeiros. Verifique o console para detalhes.");
                // Poderia tentar recarregar ou mostrar uma mensagem mais persistente
            } finally {
                setLoadingState(false); // Finaliza o estado de carregamento
            }
        }
        function applyFiltersAndUpdateUI() {
            if (isLoading) return; // Não atualiza se ainda estiver carregando
            console.log("Aplicando filtros e atualizando UI:", currentFilters);
            const today = new Date();
            today.setHours(0, 0, 0, 0); // Zera horas para comparar só a data
            const todayUTC = new Date(Date.UTC(today.getFullYear(), today.getMonth(), today.getDate()));
            const todayISO = toISODateString(todayUTC);

            displayedEntries = allDbEntries.filter(entry => {
                // Filtro por TIPO
                if (currentFilters.type !== 'all' && entry.type !== currentFilters.type) {
                    return false;
                }
                // Filtro por STATUS
                if (currentFilters.status !== 'all') {
                    const entryDate = parseDate(entry.date);
                    const isOverdue = entryDate && entryDate < todayUTC;
                    let isComplete = entry.isPaid || entry.isDelivered || false; // Pago OU Entregue

                    if (currentFilters.status === 'pending' && isComplete) return false; // Se quer pendente, ignora completo
                    if (currentFilters.status === 'paid' && !isComplete) return false;    // Se quer concluído, ignora não completo
                    if (currentFilters.status === 'overdue' && (isComplete || !isOverdue)) return false; // Se quer atrasado, ignora completo ou não atrasado
                }
                return true; // Passou por todos os filtros
            });

            console.log(`Exibindo ${displayedEntries.length} entradas após filtros.`);
            renderCalendar(); // Redesenha o calendário com os dados filtrados
            updateSummary();  // Atualiza a barra de resumo
        }

        // --- UI Rendering ---
        function renderCalendar() {
            const year = currentDate.getFullYear();
            const month = currentDate.getMonth();
            monthDisplayEl.textContent = `${getMonthName(month)} ${year}`;
            calendarDaysEl.innerHTML = ''; // Limpa o grid de dias

            const firstDayOfMonth = new Date(Date.UTC(year, month, 1));
            const lastDayOfMonth = new Date(Date.UTC(year, month + 1, 0));
            const startDayOfWeek = firstDayOfMonth.getUTCDay(); // 0 = Domingo, 6 = Sábado
            const totalDaysInMonth = lastDayOfMonth.getUTCDate();

            const today = new Date();
            today.setHours(0, 0, 0, 0);
            const todayUTCString = toISODateString(new Date(Date.UTC(today.getFullYear(), today.getMonth(), today.getDate())));

            // Adiciona dias do mês anterior (se necessário)
            const lastDayOfPrevMonth = new Date(Date.UTC(year, month, 0));
            const daysInPrevMonth = lastDayOfPrevMonth.getUTCDate();
            for (let i = startDayOfWeek - 1; i >= 0; i--) {
                const day = daysInPrevMonth - i;
                const dateString = toISODateString(new Date(Date.UTC(lastDayOfPrevMonth.getUTCFullYear(), lastDayOfPrevMonth.getUTCMonth(), day)));
                calendarDaysEl.appendChild(createDayCell(day, dateString, true)); // true = isOtherMonth
            }

            // Adiciona dias do mês atual
            for (let day = 1; day <= totalDaysInMonth; day++) {
                const dateString = toISODateString(new Date(Date.UTC(year, month, day)));
                const isToday = dateString === todayUTCString;
                calendarDaysEl.appendChild(createDayCell(day, dateString, false, isToday)); // false = isOtherMonth
            }

            // Adiciona dias do próximo mês (se necessário para completar a grade)
            const totalCells = calendarDaysEl.children.length;
            const remainingCells = totalCells <= 35 ? (35 - totalCells) : (42 - totalCells); // Aponta para 5 ou 6 linhas
            const firstDayOfNextMonth = new Date(Date.UTC(year, month + 1, 1));
            for (let i = 1; i <= remainingCells; i++) {
                const dateString = toISODateString(new Date(Date.UTC(firstDayOfNextMonth.getUTCFullYear(), firstDayOfNextMonth.getUTCMonth(), i)));
                calendarDaysEl.appendChild(createDayCell(i, dateString, true));
            }
        }
        function createDayCell(day, dateString, isOtherMonth = false, isToday = false) {
            const dayElement = document.createElement('div');
            dayElement.className = 'day-cell';
            if (isOtherMonth) dayElement.classList.add('other-month');
            if (isToday) dayElement.classList.add('today');
            dayElement.dataset.date = dateString; // Armazena a data no formato YYYY-MM-DD

            const dayNumber = document.createElement('div');
            dayNumber.className = 'day-number';
            dayNumber.textContent = day;
            dayElement.appendChild(dayNumber);

            const entriesContainer = document.createElement('div');
            entriesContainer.className = 'day-entries';
            const iconList = document.createElement('div');
            iconList.className = 'entry-icon-list';

            // Filtra as entradas *já filtradas* (displayedEntries) para este dia específico
            const dayEntries = displayedEntries.filter(entry => entry.date === dateString);
            dayEntries.sort((a, b) => (a.type || '').localeCompare(b.type || '')); // Ordena por tipo para consistência

            const todayCheck = new Date(); todayCheck.setHours(0,0,0,0);
            const todayUTC = new Date(Date.UTC(todayCheck.getFullYear(), todayCheck.getMonth(), todayCheck.getDate()));

            // Exibe ícones (limitado a 4 para não poluir)
            const maxIcons = 4;
            dayEntries.slice(0, maxIcons).forEach(entry => {
                const iconWrapper = document.createElement('span');
                iconWrapper.className = `entry-icon ${entry.type}`;
                iconWrapper.title = `${entry.description || 'N/A'} (${entry.type !== 'delivery' ? formatCurrency(entry.value || 0) : 'Entrega'})`; // Tooltip

                let iconClass = 'fa-question-circle'; // Default
                if (entry.type === 'receipt') iconClass = 'fa-dollar-sign';
                else if (entry.type === 'payment') iconClass = 'fa-receipt';
                else if (entry.type === 'delivery') iconClass = 'fa-truck';
                iconWrapper.innerHTML = `<i class="fas ${iconClass}"></i>`;

                const isComplete = entry.isPaid || entry.isDelivered || false;
                const entryDate = parseDate(entry.date);
                const isOverdue = !isComplete && entryDate && entryDate < todayUTC;

                if (isComplete) iconWrapper.classList.add('completed'); // Estilo para concluído
                if (isOverdue) iconWrapper.classList.add('overdue');   // Estilo para atrasado

                iconList.appendChild(iconWrapper);
            });

            entriesContainer.appendChild(iconList);

            // Indicador "+X" se houver mais entradas do que ícones exibidos
            if (dayEntries.length > maxIcons) {
                const moreIndicator = document.createElement('div');
                moreIndicator.className = 'more-entries-indicator';
                moreIndicator.textContent = `+${dayEntries.length - maxIcons}`;
                entriesContainer.appendChild(moreIndicator);
            }

            dayElement.appendChild(entriesContainer);

            // Adiciona evento de clique apenas para dias do mês atual
            if (!isOtherMonth) {
                dayElement.addEventListener('click', () => showDayDetails(dateString));
            }

            return dayElement;
        }
        function updateSummary() {
            const year = currentDate.getFullYear();
            const month = currentDate.getMonth();
            const todayISO = toISODateString(new Date()); // Data de hoje para verificar vencidos

            let totalRecebido = 0, totalAReceber = 0, totalPago = 0, totalAPagar = 0, totalVencido = 0, deliveryCount = 0;

            // Calcula totais baseado em *todas* as entradas (allDbEntries)
            allDbEntries.forEach(entry => {
                const entryDate = parseDate(entry.date);
                const value = Number(entry.value) || 0;
                const isComplete = entry.isPaid || entry.isDelivered || false;

                // Totais do Mês Atual
                if (entryDate && entryDate.getUTCFullYear() === year && entryDate.getUTCMonth() === month) {
                    if (entry.type === 'receipt') {
                        if (isComplete) totalRecebido += value;
                        else totalAReceber += value;
                    } else if (entry.type === 'payment') {
                        if (isComplete) totalPago += value;
                        else totalAPagar += value;
                    } else if (entry.type === 'delivery') {
                        deliveryCount++; // Conta entregas do mês
                    }
                }

                // Total Vencido (apenas financeiros, não pagos e data anterior a hoje)
                if (entry.type !== 'delivery' && !isComplete && entry.date && entry.date < todayISO) {
                    totalVencido += value;
                }
            });

            // Atualiza os elementos no HTML
            summaryRecebidoEl.textContent = formatCurrency(totalRecebido);
            summaryAReceberEl.textContent = formatCurrency(totalAReceber);
            summaryPagoEl.textContent = formatCurrency(totalPago);
            summaryAPagarEl.textContent = formatCurrency(totalAPagar);
            summaryVencidoEl.textContent = formatCurrency(totalVencido);
            summaryDeliveriesCountEl.textContent = deliveryCount;

            // Mostra/Esconde itens do resumo baseado no filtro de TIPO ativo
            const currentTypeFilter = currentFilters.type;
            summaryItemRecebido.classList.toggle('hidden', currentTypeFilter === 'payment' || currentTypeFilter === 'delivery');
            summaryItemAReceber.classList.toggle('hidden', currentTypeFilter === 'payment' || currentTypeFilter === 'delivery');
            summaryItemPago.classList.toggle('hidden', currentTypeFilter === 'receipt' || currentTypeFilter === 'delivery');
            summaryItemAPagar.classList.toggle('hidden', currentTypeFilter === 'receipt' || currentTypeFilter === 'delivery');
            summaryItemDeliveries.classList.toggle('hidden', currentTypeFilter !== 'delivery'); // Mostra só se filtro for 'delivery'
            summaryItemVencido.classList.toggle('hidden', currentTypeFilter === 'delivery'); // Esconde vencido se filtro for 'delivery'
        }

        // --- Modal & Action Logic ---
        function showDayDetails(dateString) {
            const date = parseDate(dateString);
            if (!date) return; // Segurança

            dayDetailTitleEl.textContent = `Detalhes para ${formatDate(dateString)}`;
            dayDetailEntriesEl.innerHTML = '<div class="loading-indicator"><i class="fas fa-spinner fa-spin"></i> Carregando...</div>'; // Feedback
            dayDetailModalEl.style.display = 'block'; // Mostra o modal

            // Usar setTimeout para permitir que o modal apareça antes de popular
            setTimeout(() => {
                dayDetailEntriesEl.innerHTML = ''; // Limpa o conteúdo
                // Filtra as entradas *exibidas* (já filtradas por tipo/status global) para este dia
                const entriesToShow = displayedEntries.filter(e => e.date === dateString);

                if (entriesToShow.length === 0) {
                    dayDetailEntriesEl.innerHTML = '<p class="placeholder">Nenhum lançamento para exibir com os filtros atuais.</p>';
                    return;
                }

                // Ordena as entradas dentro do modal (ex: Entregas primeiro)
                entriesToShow.sort((a, b) => {
                    const typeOrder = { 'delivery': 0, 'receipt': 1, 'payment': 2 };
                    if (typeOrder[a.type] !== typeOrder[b.type]) return typeOrder[a.type] - typeOrder[b.type];
                    return (a.description || '').localeCompare(b.description || ''); // Desempate por descrição
                });

                const today = new Date(); today.setHours(0,0,0,0);
                const todayUTC = new Date(Date.UTC(today.getFullYear(), today.getMonth(), today.getDate()));

                entriesToShow.forEach(entry => {
                    const entryDiv = document.createElement('div');
                    entryDiv.className = `day-entry ${entry.type}`; // Classe baseada no tipo
                    // Armazena dados importantes no elemento para fácil acesso nas ações
                    entryDiv.dataset.entryId = entry.id || '';
                    entryDiv.dataset.entryType = entry.type || '';
                    entryDiv.dataset.originalId = entry.originalId || entry.id || ''; // Para recorrências
                    entryDiv.dataset.isGenerated = entry.isGenerated || false; // Para recorrências

                    let statusText = 'Pendente';
                    let isComplete = entry.isPaid || entry.isDelivered || false;
                    const entryDate = parseDate(entry.date);
                    const isEntryOverdue = !isComplete && entryDate && entryDate < todayUTC;

                    if (isComplete) statusText = entry.type === 'delivery' ? 'Entregue' : 'Pago';
                    else if (isEntryOverdue) statusText = entry.type === 'delivery' ? 'Entrega Atrasada' : 'Vencido';

                    // Adiciona classes para estilização de status
                    if (isComplete) entryDiv.classList.add('paid'); // Ou 'delivered'
                    if (isEntryOverdue && !isComplete) entryDiv.classList.add('overdue');

                    // Ícone correspondente ao tipo
                    let iconClass = 'fa-question-circle';
                    if (entry.type === 'receipt') iconClass = 'fa-dollar-sign';
                    else if (entry.type === 'payment') iconClass = 'fa-receipt';
                    else if (entry.type === 'delivery') iconClass = 'fa-truck';

                    // Monta o HTML dos detalhes
                    let detailsHtml = `<h4><i class="fas ${iconClass}"></i> ${entry.description || 'Sem Descrição'}</h4>`;
                    if (entry.type !== 'delivery') detailsHtml += `<p><strong>Valor:</strong> ${formatCurrency(entry.value || 0)}</p>`;
                    if (entry.clientName) detailsHtml += `<p><strong>Cliente:</strong> ${entry.clientName}</p>`;
                    if (entry.supplier) detailsHtml += `<p><strong>Fornecedor:</strong> ${entry.supplier}</p>`;
                    if (entry.numeroPedido && entry.type === 'delivery') detailsHtml += `<p><strong>Pedido:</strong> ${entry.numeroPedido}</p>`;
                    detailsHtml += `<p><strong>Data:</strong> ${formatDate(entry.date || '')}</p>`;
                    detailsHtml += `<p><strong>Status:</strong> ${statusText}</p>`;
                    if (entry.type === 'payment' && entry.isRecurringRule && !entry.isGenerated) detailsHtml += `<p><strong>Recorrência:</strong> ${entry.recurrenceType === 'weekly' ? 'Semanal' : 'Mensal'} (Regra)</p>`;

                    // Monta o HTML das ações (botões)
                    let actionsHtml = '<div class="day-entry-actions">';
                    if (entry.type === 'receipt') {
                        if (!isComplete) {
                            actionsHtml += `<button class="btn-paid" data-action="mark-paid"><i class="fas fa-check"></i> Marcar Pago</button> `; // Adiciona "Marcar"
                            actionsHtml += `<button class="btn-edit" data-action="edit"><i class="fas fa-edit"></i> Editar</button> `;
                            if(entry.clientPhone) { // Mostra botão do WhatsApp apenas se houver telefone
                                actionsHtml += `<button class="btn-whatsapp" data-action="whatsapp"><i class="fab fa-whatsapp"></i> Cobrar</button> `; // Adiciona "Cobrar"
                            }
                        }
                        // Excluir sempre visível para recibos
                        actionsHtml += `<button class="btn-delete" data-action="delete"><i class="fas fa-trash"></i> Excluir</button>`;
                    } else if (entry.type === 'payment') {
                        if (!isComplete) actionsHtml += `<button class="btn-paid" data-action="mark-paid"><i class="fas fa-check"></i> Marcar Pago</button> `;
                        // Lógica para pagamentos recorrentes
                        if (!entry.isGenerated) { // Se for a regra original ou um pagamento único
                            actionsHtml += `<button class="btn-edit" data-action="edit"><i class="fas fa-edit"></i> Editar${entry.isRecurringRule ? ' Regra' : ''}</button> `;
                            actionsHtml += `<button class="btn-delete" data-action="delete"><i class="fas fa-trash"></i> Excluir${entry.isRecurringRule ? ' Regra' : ''}</button>`;
                        } else { // Se for uma instância gerada
                            // Poderia adicionar um botão para editar a instância (ajustar data/valor?), mas mantendo simples por agora.
                            actionsHtml += `<button class="btn-delete" data-action="delete-instance" title="Excluir apenas esta ocorrência"><i class="fas fa-times"></i> Excluir Ocorrência</button>`;
                        }
                    } else if (entry.type === 'delivery') {
                        if (!isComplete) actionsHtml += `<button class="btn-delivered" data-action="mark-delivered"><i class="fas fa-check"></i> Marcar Entregue</button> `;
                        // Link para ver o pedido/orçamento se o ID existir
                        if (entry.orcamentoId) actionsHtml += `<a href="telaorcamento.html?orcamentoId=${entry.orcamentoId}"  target="conteudo" class="btn-view-order"><i class="fas fa-file-alt"></i> Ver Pedido</a> `;
                        // Poderia adicionar um botão de excluir entrega se fizesse sentido
                    }
                    actionsHtml += '</div>';

                    entryDiv.innerHTML = detailsHtml + actionsHtml; // Combina detalhes e ações
                    dayDetailEntriesEl.appendChild(entryDiv); // Adiciona ao modal
                });
            }, 10); // Pequeno delay para renderização inicial do modal
        }
        function openAddEditModal(entry = null) {
            entryFormEl.reset(); // Limpa o formulário
            // Reseta campos hidden e outros defaults
            entryIdInput.value = '';
            entryOriginalIdInput.value = '';
            entryIsGeneratedInput.value = 'false';
            entryClientSelect.value = ''; // Reseta select de cliente
            entryPaidCheckbox.checked = false; // Reseta checkbox pago

            const isEditing = !!entry;
            entryModalTitleEl.textContent = isEditing ? `Editar ${entry.type === 'receipt' ? 'Recebimento' : 'Pagamento'}` : 'Novo Lançamento';
            entryTypeSelect.disabled = isEditing; // Não permite mudar o tipo ao editar

            if (isEditing) {
                // Preenche o formulário com os dados da entrada existente
                entryIdInput.value = entry.id || '';
                entryOriginalIdInput.value = entry.originalId || ''; // Para recorrências
                entryIsGeneratedInput.value = entry.isGenerated ? 'true' : 'false'; // Importante para lógica de recorrência
                entryTypeSelect.value = entry.type || 'receipt';
                document.getElementById('entry-description').value = entry.description || '';
                document.getElementById('entry-value').value = entry.value || 0;
                document.getElementById('entry-date').value = entry.date || ''; // Data YYYY-MM-DD

                if (entry.type === 'receipt') {
                    // Encontra e seleciona o cliente no select
                    const clientJsonString = Array.from(entryClientSelect.options).find(opt => {
                        try { return opt.value && JSON.parse(opt.value).id === entry.clientId; } catch { return false; }
                    })?.value;
                    entryClientSelect.value = clientJsonString || ""; // Define o valor do select
                } else { // Pagamento
                    document.getElementById('entry-supplier').value = entry.supplier || '';
                    entryRecurrenceSelect.value = entry.recurrenceType || 'none';
                    entryPaidCheckbox.checked = entry.isPaid || false; // Define o estado do checkbox
                }
            } else { // Adicionando novo lançamento
                entryTypeSelect.value = 'receipt'; // Default para recebimento
                document.getElementById('entry-date').value = toISODateString(new Date()); // Data de hoje como default
                entryRecurrenceSelect.value = 'none'; // Default sem recorrência
            }

            toggleEntryTypeFields(); // Mostra/esconde campos baseado no tipo e se é edição
            entryModalEl.style.display = 'block'; // Mostra o modal de adicionar/editar
        }
        function toggleEntryTypeFields() {
            const type = entryTypeSelect.value;
            const isEditing = !!entryIdInput.value;
            const isGenerated = entryIsGeneratedInput.value === 'true'; // Lê do input hidden

            // Mostra/esconde campos de Cliente vs Fornecedor/Recorrência
            receiptFields.forEach(el => el.classList.toggle('hidden', type !== 'receipt'));
            paymentFields.forEach(el => el.classList.toggle('hidden', type !== 'payment'));

            // Campo de Recorrência (select) - visível apenas para Pagamentos
            const recurrenceFieldGroup = entryRecurrenceSelect.closest('.form-group.payment-field');
            if(recurrenceFieldGroup) recurrenceFieldGroup.classList.toggle('hidden', type !== 'payment');

            // Desabilita o select de recorrência se estiver editando uma *instância gerada*
            entryRecurrenceSelect.disabled = isGenerated;

            // Campo "Marcar Pago?" (checkbox)
            const paidFieldGroup = entryPaidCheckbox.closest('.form-group.payment-field.checkbox-group');
            if (paidFieldGroup) {
                // Visível apenas ao *editar* um pagamento que *não é* uma instância gerada
                paidFieldGroup.classList.toggle('hidden', !(isEditing && type === 'payment' && !isGenerated));
            }
        }
        async function saveEntry(event) {
            event.preventDefault(); // Impede envio padrão do formulário
            setLoadingState(true); // Inicia feedback de carregamento

            const id = entryIdInput.value; // ID da entrada (se editando)
            const type = entryTypeSelect.value; // 'receipt' ou 'payment'
            const originalId = entryOriginalIdInput.value; // Para recorrências
            const isGenerated = entryIsGeneratedInput.value === 'true'; // Para recorrências

            // Coleta dados básicos do formulário
            const data = {
                descricao: document.getElementById('entry-description').value.trim(),
                valor: parseFloat(document.getElementById('entry-value').value) || 0,
                dataPagamento: document.getElementById('entry-date').value, // Data YYYY-MM-DD
                // createdAt é adicionado apenas para novos itens
            };

            // Validação básica
            if (!data.descricao || data.valor <= 0 || !data.dataPagamento) {
                alert("Por favor, preencha Descrição, Valor (maior que zero) e Data.");
                setLoadingState(false);
                return;
            }

            let collectionName; // Nome da coleção no Firestore
            let needsRecurrenceGeneration = false; // Flag para (re)gerar instâncias
            let oldRecurrenceType = 'none'; // Para detectar mudança na recorrência
            let ruleIdForGeneration = id && !isGenerated ? id : null; // ID da regra a ser usada

            // Prepara dados específicos por tipo
            if (type === 'receipt') {
                collectionName = 'recebimentos';
                const clientSelectValue = entryClientSelect.value;
                const clientData = clientSelectValue ? JSON.parse(clientSelectValue) : null;
                data.clienteId = clientData?.id || null;
                data.clienteNome = clientData?.nome || null;
                data.telefone = clientData?.telefone || null; // Salva telefone junto
                // Mantém o status 'pago' existente ao editar, ou false se for novo
                const currentReceipt = allDbEntries.find(e => e.id === id && e.type === 'receipt');
                data.pago = id ? (currentReceipt?.isPaid || false) : false;
            } else { // Pagamento
                collectionName = 'pagamentos';
                data.fornecedor = document.getElementById('entry-supplier').value.trim() || null;

                // Lógica de Recorrência (só se aplica se não for uma instância gerada)
                const recurrenceValue = isGenerated ? 'none' : entryRecurrenceSelect.value;
                data.isRecurringRule = !isGenerated && recurrenceValue !== 'none';
                data.recurrenceType = recurrenceValue;
                data.isGenerated = isGenerated; // Define se é uma instância gerada
                // Define o ID da regra original
                data.originalRuleId = isGenerated ? originalId : (data.isRecurringRule ? ruleIdForGeneration : null);

                if (id && !isGenerated) { // Editando uma regra ou pagamento único existente
                    const currentPayment = allDbEntries.find(e => e.id === id && e.type === 'payment');
                    oldRecurrenceType = currentPayment?.recurrenceType || 'none';
                    data.pago = entryPaidCheckbox.checked; // Pega status do checkbox (visível neste caso)
                    // Verifica se precisa regerar instâncias (mudou tipo de recorrência, data, valor, descrição, ou deixou de ser recorrente)
                    needsRecurrenceGeneration = (data.isRecurringRule || oldRecurrenceType !== 'none') &&
                                                (data.recurrenceType !== oldRecurrenceType ||
                                                 data.dataPagamento !== currentPayment?.date ||
                                                 data.valor !== currentPayment?.valor ||
                                                 data.descricao !== currentPayment?.description);
                    data.originalRuleId = data.isRecurringRule ? id : null; // Garante que originalRuleId é o próprio ID se for regra
                } else if (id && isGenerated) {
                    // Bloqueia a edição de instâncias geradas através deste formulário principal
                    alert("Edição de ocorrências geradas não é suportada aqui. Exclua e edite a regra original.");
                    setLoadingState(false);
                    return;
                } else { // Adicionando um novo pagamento
                    data.pago = entryPaidCheckbox.checked; // Checkbox não é visível, mas pegamos o valor (será false)
                    data.isGenerated = false;
                    data.originalRuleId = null; // Será definido depois se for regra
                    needsRecurrenceGeneration = data.isRecurringRule; // Precisa gerar se for uma nova regra
                    data.createdAt = Timestamp.now(); // Adiciona data de criação
                    if(data.isRecurringRule) ruleIdForGeneration = null; // ID da regra ainda não existe
                }
            }

            // Salva no Firestore
            try {
                let currentDocRef;
                if (id && !isGenerated) { // Atualiza documento existente (regra ou item único)
                    currentDocRef = doc(db, collectionName, id);
                    await updateDoc(currentDocRef, data);
                    console.log("Documento atualizado:", id);
                } else if (!id) { // Adiciona novo documento
                    data.createdAt = Timestamp.now(); // Garante timestamp de criação
                    currentDocRef = await addDoc(collection(db, collectionName), data);
                    console.log("Novo documento adicionado:", currentDocRef.id);
                    // Se for uma nova regra de pagamento, atualiza o próprio documento com seu ID como originalRuleId
                    if (type === 'payment' && data.isRecurringRule) {
                        ruleIdForGeneration = currentDocRef.id; // O ID da regra é o ID do doc recém-criado
                        await updateDoc(currentDocRef, { originalRuleId: ruleIdForGeneration });
                        console.log("Definido ID da regra de recorrência:", ruleIdForGeneration);
                    }
                } else {
                    // Não faz nada se for tentativa de salvar instância gerada (já bloqueado antes)
                    console.error("Tentativa de salvar instância gerada foi ignorada.");
                    needsRecurrenceGeneration = false; // Garante que não tente gerar
                }

                // Lida com a geração/regeneração de instâncias recorrentes
                if (needsRecurrenceGeneration && ruleIdForGeneration) {
                    console.log("Regerando/Gerando instâncias recorrentes para a regra:", ruleIdForGeneration);
                    // Busca os dados atualizados da regra
                    const ruleSnap = await getDoc(doc(db, "pagamentos", ruleIdForGeneration));
                    if(ruleSnap.exists()){
                        const ruleData = { id: ruleSnap.id, ...ruleSnap.data() };
                        // 1. Exclui instâncias futuras NÃO PAGAS
                        await deleteFutureGeneratedInstances(ruleIdForGeneration, data.dataPagamento);
                        // 2. Gera novas instâncias se a regra ainda for recorrente
                        if (ruleData.isRecurringRule && ruleData.recurrenceType !== 'none') {
                            await generateAndSaveRecurringInstances(ruleIdForGeneration, ruleData);
                        }
                    } else {
                         console.warn("Regra não encontrada para gerar instâncias:", ruleIdForGeneration);
                    }
                } else if (needsRecurrenceGeneration) {
                    // Caso algo dê errado e precise gerar mas não tenha o ID
                    console.warn("Geração de recorrência necessária, mas ID da regra não está disponível.");
                }

                entryModalEl.style.display = 'none'; // Fecha o modal
                await loadAllData(); // Recarrega TODOS os dados e atualiza a UI

            } catch (error) {
                console.error("Erro ao salvar entrada:", error);
                alert(`Ocorreu um erro ao salvar: ${error.message}`);
            } finally {
                setLoadingState(false); // Finaliza feedback de carregamento
            }
        }

        // --- Recurrence Generation/Deletion ---
        async function deleteFutureGeneratedInstances(originalRuleId, fromDateISO) {
            console.log(`Excluindo futuras instâncias NÃO PAGAS da regra ${originalRuleId} a partir de ${fromDateISO}`);
            // Query para encontrar instâncias geradas, não pagas, a partir da data informada
            const q = query(collection(db, "pagamentos"),
                where("originalRuleId", "==", originalRuleId),
                where("isGenerated", "==", true),
                where("dataPagamento", ">=", fromDateISO),
                where("pago", "==", false) // Apenas não pagas
            );
            try {
                const snapshot = await getDocs(q);
                if (!snapshot.empty) {
                    // Usa WriteBatch para excluir em lote (mais eficiente e atômico até 500 operações)
                    const batch = writeBatch(db);
                    let deleteCount = 0;
                    snapshot.docs.forEach(doc => {
                        if(deleteCount < 499){ // Limite do batch
                           batch.delete(doc.ref);
                           deleteCount++;
                        }
                        // Se houver mais de 499, seria necessário múltiplos batches
                    });
                    await batch.commit();
                    console.log(`Excluídas ${deleteCount} ocorrências futuras não pagas.`);
                } else {
                    console.log("Nenhuma ocorrência futura não paga encontrada para excluir.");
                }
            } catch(e) {
                console.error("Erro ao excluir futuras instâncias recorrentes:", e);
                // Considerar alertar o usuário ou tentar novamente
            }
        }
        async function generateAndSaveRecurringInstances(originalRuleId, originalData) {
            const recurrenceType = originalData.recurrenceType || 'none';
            const startDate = parseDate(originalData.dataPagamento); // Data de início da regra

            if (!startDate || recurrenceType === 'none') {
                console.log("Não é possível gerar recorrências: data inválida ou tipo 'none'.");
                return;
            }
            console.log(`Gerando ${recurrenceType} instâncias para a regra ${originalRuleId} a partir de ${originalData.dataPagamento}`);

            const batch = writeBatch(db);
            let count = 0;
            const generationLimit = 12; // Gera para os próximos 12 períodos (1 ano para mensal)
            let nextDate = new Date(startDate); // Começa com a data da regra

            while (count < generationLimit) {
                let instanceDate = new Date(nextDate); // Cria cópia para modificar

                // Calcula a próxima data baseado no tipo de recorrência
                if (recurrenceType === 'weekly') {
                    instanceDate.setUTCDate(instanceDate.getUTCDate() + 7);
                } else if (recurrenceType === 'monthly') {
                    const originalDay = startDate.getUTCDate(); // Mantém o dia do mês original
                    instanceDate.setUTCMonth(instanceDate.getUTCMonth() + 1);
                    // Ajusta para o dia correto (cuidado com meses de tamanhos diferentes)
                    instanceDate = new Date(Date.UTC(instanceDate.getUTCFullYear(), instanceDate.getUTCMonth(), originalDay));
                     // Verifica se o mês pulou (ex: dia 31 em mês com 30 dias), se sim, ajusta para o último dia do mês correto
                     if (instanceDate.getUTCMonth() !== (nextDate.getUTCMonth() + 1) % 12) {
                         instanceDate = new Date(Date.UTC(nextDate.getUTCFullYear(), nextDate.getUTCMonth() + 1, 0)); // Último dia do mês desejado
                     }
                } else {
                    break; // Tipo de recorrência inválido ou 'none'
                }

                if (count >= generationLimit) break; // Segurança extra

                // Cria os dados da instância
                const instanceData = {
                    descricao: originalData.descricao || '',
                    valor: originalData.valor || 0,
                    fornecedor: originalData.fornecedor || null,
                    dataPagamento: toISODateString(instanceDate), // Data calculada
                    pago: false, // Instâncias geradas começam como não pagas
                    isRecurringRule: false, // Não é a regra em si
                    recurrenceType: 'none', // Instância não tem tipo de recorrência
                    isGenerated: true, // Marca como gerada
                    originalRuleId: originalRuleId, // Link para a regra original
                    createdAt: originalData.createdAt || Timestamp.now() // Mantém timestamp da regra original
                };
                delete instanceData.id; // Garante que não tente salvar com ID antigo

                // Adiciona a operação de criação ao batch
                const newInstanceRef = doc(collection(db, "pagamentos")); // Gera nova referência
                batch.set(newInstanceRef, instanceData);

                nextDate = instanceDate; // Atualiza a data para o próximo cálculo
                count++;

                 // Limite de segurança para evitar loops infinitos em caso de erro lógico
                 if (count > generationLimit + 5) {
                     console.error("Loop de geração de recorrência excedeu limite de segurança.");
                     break;
                 }
            }

            // Se alguma instância foi adicionada ao batch, commita
            if (count > 0) {
                try {
                    await batch.commit();
                    console.log(`Salvas ${count} novas ocorrências recorrentes.`);
                } catch(e){
                    console.error("Erro ao salvar batch de recorrências:", e);
                    // O batch inteiro falha se uma operação falhar
                }
            } else {
                 console.log("Nenhuma nova instância recorrente foi gerada.");
            }
        }
        // --- End Recurrence ---

        // --- WhatsApp Cobrança ---
        function cobrarViaWhatsapp(paymentData) {
            // Usa o campo clientPhone que foi adicionado ao objeto 'entry'
            const phoneField = paymentData?.clientPhone || null;
            if (!phoneField) {
                alert('Telefone do cliente não disponível para este recebimento.');
                return;
            }
            const telefone = phoneField.replace(/\D/g, ''); // Remove não-dígitos
            if(!telefone || telefone.length < 10) { // Validação mínima de telefone BR
                alert('Número de telefone inválido.');
                return;
            }

            // Formata os dados para a mensagem
            const valorFormatado = formatCurrency(paymentData.value || 0);
            const dataFormatada = formatDate(paymentData.date || '');
            const descricao = paymentData.description || 'Recebimento';
            const clienteNome = paymentData.clientName || 'Cliente';

            // Monta a mensagem (personalize como desejar)
            const mensagem = encodeURIComponent(
`Olá ${clienteNome}! 👋

Gostaríamos de lembrar sobre o recebimento pendente referente a:
*Descrição:* ${descricao}
*Valor:* ${valorFormatado}
*Vencimento:* ${dataFormatada}

Agradecemos a sua atenção e aguardamos a regularização.

Atenciosamente,
JSFER` // Adapte a assinatura
            );

            // Cria a URL do WhatsApp (Assume prefixo 55 para Brasil)
            const whatsappUrl = `https://wa.me/${telefone}?text=${mensagem}`;
            console.log("Abrindo URL do WhatsApp:", whatsappUrl);
            window.open(whatsappUrl, '_blank'); // Abre em nova aba/app
        }
        // --- End WhatsApp Cobrança ---

        async function handleEntryActionClick(event) {
            const button = event.target.closest('button[data-action]'); // Encontra o botão clicado
            if (!button || button.disabled) return; // Ignora se não for um botão de ação ou estiver desabilitado

            const action = button.dataset.action; // Pega a ação (e.g., 'edit', 'mark-paid')
            const entryElement = button.closest('.day-entry'); // Encontra o elemento pai da entrada
            // Pega os dados da entrada armazenados no elemento
            const entryId = entryElement?.dataset.entryId;
            const entryType = entryElement?.dataset.entryType;
            const isGenerated = entryElement?.dataset.isGenerated === 'true';

            if (!entryId || !entryType) {
                console.error("Não foi possível obter ID ou Tipo da entrada para a ação.");
                return;
            }

            // Encontra os dados completos da entrada no array principal (para ter todos os campos)
            const entryData = allDbEntries.find(e => e.id === entryId);

            console.log(`Ação: ${action}`, { entryId, entryType, isGenerated, entryData }); // Log para debug
            // Feedback visual e bloqueio do botão
            button.disabled = true;
            const originalButtonHTML = button.innerHTML;
            button.innerHTML = '<i class="fas fa-spinner fa-spin"></i>';

            let needsReload = true; // Flag para saber se precisa recarregar dados
            let closeModal = true;  // Flag para saber se fecha o modal de detalhes

            try {
                let collectionName = entryType === 'receipt' ? 'recebimentos' : entryType === 'payment' ? 'pagamentos' : 'pedidos'; // 'pedidos' para delivery
                let docRef = doc(db, collectionName, entryId); // Referência ao documento no Firestore

                // Executa a ação correspondente
                if (action === 'edit') {
                    closeModal = false; // Não fecha modal de detalhes, abre o de edição
                    if (isGenerated && entryType === 'payment') {
                        alert("Para editar uma ocorrência recorrente, por favor, edite a regra original.");
                        throw new Error("Attempted to edit generated instance via main edit button.");
                    }
                    if (entryData) {
                        openAddEditModal(entryData); // Abre modal de edição preenchido
                        needsReload = false; // Não precisa recarregar, pois a edição ainda não foi salva
                    } else {
                         throw new Error("Dados completos da entrada não encontrados para edição.");
                    }
                }
                else if (action === 'mark-paid') { // Marca Pagamento ou Recebimento como pago
                    await updateDoc(docRef, { pago: true });
                    console.log(`Entrada ${entryId} marcada como paga.`);
                }
                else if (action === 'mark-delivered') { // Marca Entrega como concluída
                     await updateDoc(docRef, { entregue: true, dataEntregaReal: Timestamp.now() }); // Adiciona data real da entrega
                     console.log(`Entrega ${entryId} marcada como concluída.`);
                }
                else if (action === 'delete' || action === 'delete-instance') { // Excluir
                    let confirmMsg = `Tem certeza que deseja excluir este lançamento?`;
                    let isRule = false;
                    // Mensagem específica se for excluir uma REGRA de pagamento recorrente
                    if(action === 'delete' && entryType === 'payment' && !isGenerated){
                        isRule = entryData?.isRecurringRule || false;
                        if(isRule) confirmMsg = "ATENÇÃO: Excluir esta REGRA também excluirá todas as ocorrências futuras NÃO PAGAS. Deseja continuar?";
                    } else if(action === 'delete-instance') {
                        confirmMsg = "Tem certeza que deseja excluir APENAS esta ocorrência do pagamento recorrente?";
                    }

                    if (confirm(confirmMsg)) { // Pede confirmação
                        await deleteDoc(docRef); // Exclui o documento principal
                        console.log(`Documento ${entryId} excluído.`);
                        // Se excluiu uma regra, exclui também as instâncias futuras não pagas
                        if (isRule) {
                            await deleteFutureGeneratedInstances(entryId, toISODateString(new Date())); // Exclui a partir de hoje
                        }
                    } else {
                        needsReload = false; // Cancelou, não precisa recarregar
                        closeModal = false; // Mantém modal aberto
                        throw new Error("Exclusão cancelada pelo usuário."); // Para cair no catch e reabilitar botão
                    }
                }
                else if (action === 'whatsapp') { // Cobrar via WhatsApp
                    needsReload = false; // Não modifica dados, não recarrega
                    closeModal = false; // Não fecha o modal
                    if (entryData && entryData.type === 'receipt') { // Garante que é um recebimento
                        cobrarViaWhatsapp(entryData); // Chama a função de cobrar
                    } else {
                        throw new Error("Dados inválidos ou tipo incorreto para cobrança via WhatsApp.");
                    }
                }

                // --- Recarregamento e Atualização da UI ---
                if (needsReload) {
                    console.log("Ação concluída, recarregando dados...");
                    await loadAllData(); // Espera o recarregamento completo dos dados
                    console.log("Dados recarregados, UI será atualizada.");
                    // A função loadAllData já chama applyFiltersAndUpdateUI -> renderCalendar e updateSummary
                }
                // --- Fim Recarregamento ---

                if (closeModal) {
                     // Fecha o modal APÓS o possível recarregamento
                    dayDetailModalEl.style.display = 'none';
                }

            } catch(error) {
                console.error(`Erro ao executar ação ${action}:`, error);
                // Não mostra alerta se for apenas cancelamento de exclusão
                if (error.message !== "Exclusão cancelada pelo usuário." && !error.message.includes("Attempted to edit generated")) {
                    alert(`Erro ao processar a ação: ${error.message || 'Ocorreu um problema inesperado.'}`);
                }
                closeModal = false; // Mantém o modal aberto em caso de erro
            } finally {
                // Restaura o botão para o estado original APÓS todas as operações
                // Precisa verificar se o botão ainda existe (modal pode ter fechado)
                 setTimeout(() => { // Adiciona um pequeno delay para garantir que o DOM atualizou
                     const finalButtonCheck = entryElement?.querySelector(`button[data-action="${action}"]`);
                     if(finalButtonCheck) { // Se o botão ainda existir no DOM
                         finalButtonCheck.disabled = false;
                         finalButtonCheck.innerHTML = originalButtonHTML;
                     } else if (!closeModal) {
                         // Se o modal não fechou, mas o botão sumiu (improvável), restaura o original
                          button.disabled = false;
                          button.innerHTML = originalButtonHTML;
                     }
                 }, 50); // 50ms de delay
            }
        }

        // --- Função para Gerar Relatórios ---
        async function gerarRelatorioCombinado() {
            console.log("Gerando Relatório Combinado para o mês atual...");
            const year = currentDate.getFullYear();
            const month = currentDate.getMonth();
            reportModalEl.style.display = 'block'; // Mostra o modal de relatórios

            // --- Cálculo do Balancete ---
            let totalRecebidoMes = 0;
            let totalPagoMes = 0;
            allDbEntries.forEach(entry => {
                const entryDate = parseDate(entry.date);
                // Filtra pelo mês/ano atual
                if (entryDate && entryDate.getUTCFullYear() === year && entryDate.getUTCMonth() === month) {
                    if (entry.type === 'receipt' && entry.isPaid) { // Apenas recebimentos pagos
                        totalRecebidoMes += (Number(entry.value) || 0);
                    } else if (entry.type === 'payment' && entry.isPaid) { // Apenas pagamentos efetuados
                        totalPagoMes += (Number(entry.value) || 0);
                    }
                }
            });
            const saldo = totalRecebidoMes - totalPagoMes;
            // Atualiza o modal
            reportBalanceteRecebidoEl.textContent = formatCurrency(totalRecebidoMes);
            reportBalancetePagoEl.textContent = formatCurrency(totalPagoMes);
            reportBalanceteSaldoEl.textContent = formatCurrency(saldo);
            reportBalanceteSaldoEl.className = saldo >= 0 ? 'positivo' : 'negativo'; // Estiliza o saldo

             // --- Cálculo do Demonstrativo por Cliente ---
            const receiptsThisMonth = allDbEntries.filter(entry => {
                const entryDate = parseDate(entry.date);
                return entry.type === 'receipt' && entryDate && entryDate.getUTCFullYear() === year && entryDate.getUTCMonth() === month;
            });

            reportDemonstrativoListEl.innerHTML = ''; // Limpa lista anterior
            if (receiptsThisMonth.length === 0) {
                reportDemonstrativoListEl.innerHTML = '<p class="placeholder">Nenhum recebimento registrado neste mês.</p>';
            } else {
                // Agrupa recebimentos por cliente
                const summaryByClient = {};
                receiptsThisMonth.forEach(p => {
                    const clientId = p.clientId || 'sem_cliente_id'; // Chave para agrupar
                    const clientName = p.clientName || 'Cliente Não Identificado'; // Nome para exibição
                    if (!summaryByClient[clientId]) {
                        summaryByClient[clientId] = { name: clientName, paid: 0, pending: 0, total: 0 };
                    }
                    const value = Number(p.value) || 0;
                    summaryByClient[clientId].total += value;
                    if (p.isPaid) summaryByClient[clientId].paid += value;
                    else summaryByClient[clientId].pending += value;
                });
                // Converte o objeto em array e ordena por nome do cliente
                const clientsSummaryArray = Object.values(summaryByClient).sort((a, b) => a.name.localeCompare(b.name));
                // Cria o HTML para cada cliente
                clientsSummaryArray.forEach(cs => {
                    const div = document.createElement('div');
                    div.innerHTML = `
                        <h4>${cs.name}</h4>
                        <p>Total Recebimentos no Mês: <strong>${formatCurrency(cs.total)}</strong></p>
                        <p>Total Pago: <strong style="color:var(--clr-success);">${formatCurrency(cs.paid)}</strong></p>
                        <p>Total Pendente: <strong style="color:var(--clr-warning);">${formatCurrency(cs.pending)}</strong></p>`;
                    reportDemonstrativoListEl.appendChild(div);
                });
            }
        }

        // --- Event Listeners Setup ---
        document.addEventListener('DOMContentLoaded', () => {
            loadAllData(); // Carrega os dados iniciais quando a página estiver pronta

            // Navegação entre meses
            prevMonthBtnEl.addEventListener('click', () => { currentDate.setMonth(currentDate.getMonth() - 1); renderCalendar(); updateSummary(); });
            nextMonthBtnEl.addEventListener('click', () => { currentDate.setMonth(currentDate.getMonth() + 1); renderCalendar(); updateSummary(); });

            // Filtros (Tipo e Status) - Usa delegação de eventos
            filterTypeGroup.addEventListener('click', (e) => {
                if (e.target.tagName === 'BUTTON') {
                    filterTypeGroup.querySelectorAll('button').forEach(btn => btn.classList.remove('active'));
                    e.target.classList.add('active');
                    currentFilters.type = e.target.dataset.filterType;
                    applyFiltersAndUpdateUI(); // Reaplica filtros e atualiza UI
                }
            });
            filterStatusGroup.addEventListener('click', (e) => {
                if (e.target.tagName === 'BUTTON') {
                    filterStatusGroup.querySelectorAll('button').forEach(btn => btn.classList.remove('active'));
                    e.target.classList.add('active');
                    currentFilters.status = e.target.dataset.filterStatus;
                    applyFiltersAndUpdateUI(); // Reaplica filtros e atualiza UI
                }
            });

            // Botões de Ação Principais (Novo Lançamento, Relatórios)
            btnAddEntry.addEventListener('click', () => openAddEditModal());
            btnReports.addEventListener('click', gerarRelatorioCombinado);

            // Botões de Fechar Modais (usando atributo data-modal-id)
            modalCloseBtns.forEach(btn => {
                btn.addEventListener('click', (e) => {
                    const modalId = e.target.closest('[data-modal-id]')?.dataset.modalId; // Pega ID do botão ou do pai
                    if (modalId) {
                        const modal = document.getElementById(modalId);
                        if(modal) modal.style.display = 'none'; // Esconde o modal correspondente
                    }
                });
            });

            // Formulário de Adicionar/Editar
            entryTypeSelect.addEventListener('change', toggleEntryTypeFields); // Atualiza campos ao mudar tipo
            entryFormEl.addEventListener('submit', saveEntry); // Salva ao submeter

            // Ações dentro do Modal de Detalhes do Dia (Delegação de Eventos)
            // O listener é adicionado ao container PAI dos botões
            dayDetailEntriesEl.addEventListener('click', handleEntryActionClick);
        });

    </script>

</body>
</html>